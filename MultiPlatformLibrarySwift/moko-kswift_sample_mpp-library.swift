// This file automatically generated by MOKO KSwift (https://github.com/icerockdev/moko-kswift)
//
import Foundation
import MultiPlatformLibrary
import UIKit

/**
 * selector: ClassContext/moko-kswift.sample:mpp-library/com/icerockdev/library/GenericSealedClass */
public enum GenericSealedClassKs<T : AnyObject, U : AnyObject> {

  case withoutProperty
  case withOnePropertyT(GenericSealedClassWithOnePropertyT<T>)
  case withOnePropertyU(GenericSealedClassWithOnePropertyU<U>)
  case withTwoProperties(GenericSealedClassWithTwoProperties<T, U>)

  public var sealed: GenericSealedClass<T, U> {
    switch self {
    case .withoutProperty:
      return MultiPlatformLibrary.GenericSealedClassWithoutProperty() as! MultiPlatformLibrary.GenericSealedClass<T, U>
    case .withOnePropertyT(let obj):
      return obj as! MultiPlatformLibrary.GenericSealedClass<T, U>
    case .withOnePropertyU(let obj):
      return obj as! MultiPlatformLibrary.GenericSealedClass<T, U>
    case .withTwoProperties(let obj):
      return obj as MultiPlatformLibrary.GenericSealedClass<T, U>
    }
  }

  public init(_ obj: GenericSealedClass<T, U>) {
    if obj is MultiPlatformLibrary.GenericSealedClassWithoutProperty {
      self = .withoutProperty
    } else if let obj = obj as? MultiPlatformLibrary.GenericSealedClassWithOnePropertyT<T> {
      self = .withOnePropertyT(obj)
    } else if let obj = obj as? MultiPlatformLibrary.GenericSealedClassWithOnePropertyU<U> {
      self = .withOnePropertyU(obj)
    } else if let obj = obj as? MultiPlatformLibrary.GenericSealedClassWithTwoProperties<T, U> {
      self = .withTwoProperties(obj)
    } else {
      fatalError("GenericSealedClassKs not synchronized with GenericSealedClass class")
    }
  }

}

/**
 * selector: ClassContext/moko-kswift.sample:mpp-library/com/icerockdev/library/NonGenericSealedClass */
public enum NonGenericSealedClassKs {

  case withoutProperty
  case withProperty(NonGenericSealedClass.WithProperty)

  public var sealed: NonGenericSealedClass {
    switch self {
    case .withoutProperty:
      return MultiPlatformLibrary.NonGenericSealedClass.WithoutProperty() as MultiPlatformLibrary.NonGenericSealedClass
    case .withProperty(let obj):
      return obj as! MultiPlatformLibrary.NonGenericSealedClass
    }
  }

  public init(_ obj: NonGenericSealedClass) {
    if obj is MultiPlatformLibrary.NonGenericSealedClass.WithoutProperty {
      self = .withoutProperty
    } else if let obj = obj as? MultiPlatformLibrary.NonGenericSealedClass.WithProperty {
      self = .withProperty(obj)
    } else {
      fatalError("NonGenericSealedClassKs not synchronized with NonGenericSealedClass class")
    }
  }

}

/**
 * selector: ClassContext/moko-kswift.sample:mpp-library/com/icerockdev/library/PublicInternalInsideSealedTest */
public enum PublicInternalInsideSealedTestKs {

  case publicSealed

  public var sealed: PublicInternalInsideSealedTest {
    switch self {
    case .publicSealed:
      return MultiPlatformLibrary.PublicInternalInsideSealedTest.PublicSealed() as MultiPlatformLibrary.PublicInternalInsideSealedTest
    }
  }

  public init(_ obj: PublicInternalInsideSealedTest) {
    if obj is MultiPlatformLibrary.PublicInternalInsideSealedTest.PublicSealed {
      self = .publicSealed
    } else {
      fatalError("PublicInternalInsideSealedTestKs not synchronized with PublicInternalInsideSealedTest class")
    }
  }

}

/**
 * selector: ClassContext/moko-kswift.sample:mpp-library/com/icerockdev/library/Status */
public enum StatusKs<T : AnyObject> {

  case success(StatusSuccess<T>)
  case failure(StatusFailure<T>)

  public var sealed: Status<T> {
    switch self {
    case .success(let obj):
      return obj as MultiPlatformLibrary.Status<T>
    case .failure(let obj):
      return obj as MultiPlatformLibrary.Status<T>
    }
  }

  public init(_ obj: Status<T>) {
    if let obj = obj as? MultiPlatformLibrary.StatusSuccess<T> {
      self = .success(obj)
    } else if let obj = obj as? MultiPlatformLibrary.StatusFailure<T> {
      self = .failure(obj)
    } else {
      fatalError("StatusKs not synchronized with Status class")
    }
  }

}

/**
 * selector: ClassContext/moko-kswift.sample:mpp-library/com/icerockdev/library/UIState */
public enum UIStateKs<T : AnyObject> {

  case loading
  case empty
  case data(UIStateData<T>)
  case error(UIStateError)

  public var sealed: UIState {
    switch self {
    case .loading:
      return MultiPlatformLibrary.UIStateLoading() as MultiPlatformLibrary.UIState
    case .empty:
      return MultiPlatformLibrary.UIStateEmpty() as MultiPlatformLibrary.UIState
    case .data(let obj):
      return obj as! MultiPlatformLibrary.UIState
    case .error(let obj):
      return obj as! MultiPlatformLibrary.UIState
    }
  }

  public init(_ obj: UIState) {
    if obj is MultiPlatformLibrary.UIStateLoading {
      self = .loading
    } else if obj is MultiPlatformLibrary.UIStateEmpty {
      self = .empty
    } else if let obj = obj as? MultiPlatformLibrary.UIStateData<T> {
      self = .data(obj)
    } else if let obj = obj as? MultiPlatformLibrary.UIStateError {
      self = .error(obj)
    } else {
      fatalError("UIStateKs not synchronized with UIState class")
    }
  }

}

/**
 * selector: ClassContext/moko-kswift.sample:mpp-library/com/icerockdev/library/UIStateClass */
public enum UIStateClassKs<T : AnyObject> {

  case loading
  case empty
  case data(UIStateClassData<T>)
  case error(UIStateClassError)

  public var sealed: UIStateClass<T> {
    switch self {
    case .loading:
      return MultiPlatformLibrary.UIStateClassLoading() as! MultiPlatformLibrary.UIStateClass<T>
    case .empty:
      return MultiPlatformLibrary.UIStateClassEmpty() as! MultiPlatformLibrary.UIStateClass<T>
    case .data(let obj):
      return obj as MultiPlatformLibrary.UIStateClass<T>
    case .error(let obj):
      return obj as! MultiPlatformLibrary.UIStateClass<T>
    }
  }

  public init(_ obj: UIStateClass<T>) {
    if obj is MultiPlatformLibrary.UIStateClassLoading {
      self = .loading
    } else if obj is MultiPlatformLibrary.UIStateClassEmpty {
      self = .empty
    } else if let obj = obj as? MultiPlatformLibrary.UIStateClassData<T> {
      self = .data(obj)
    } else if let obj = obj as? MultiPlatformLibrary.UIStateClassError {
      self = .error(obj)
    } else {
      fatalError("UIStateClassKs not synchronized with UIStateClass class")
    }
  }

}

public extension UIKit.UILabel {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/UIKit/UILabel)/bindGenericAny/liveData:Class(name=com/icerockdev/library/LiveData)<TypeParameter(id=0)>
   */
  @discardableResult
  public func bindGenericAny<T>(liveData: LiveData<T>) -> Closeable {
    return UILabelExtKt.bindGenericAny(self, liveData: liveData as! MultiPlatformLibrary.LiveData<Swift.AnyObject>)
  }
}

public extension UIKit.UILabel {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/UIKit/UILabel)/bindGenericText/liveData:Class(name=com/icerockdev/library/LiveData)<TypeParameter(id=0)>
   */
  @discardableResult
  public func bindGenericText<T : NSString>(liveData: LiveData<T>) -> Closeable {
    return UILabelExtKt.bindGenericText(self, liveData: liveData as! MultiPlatformLibrary.LiveData<Foundation.NSString>)
  }
}

public extension UIKit.UILabel {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/UIKit/UILabel)/bindText/liveData:Class(name=com/icerockdev/library/LiveData)<Class(name=kotlin/String)>
   */
  @discardableResult
  public func bindText(liveData: LiveData<NSString>) -> Closeable {
    return UILabelExtKt.bindText(self, liveData: liveData)
  }
}

public extension UIKit.UILabel {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/UIKit/UILabel)/bindText/liveData:Class(name=com/icerockdev/library/LiveData)<Class(name=kotlin/String)>,formatter:Class(name=kotlin/Function1)<Class(name=kotlin/String),Class(name=kotlin/String)>
   */
  @discardableResult
  public func bindText(liveData: LiveData<NSString>, formatter: @escaping (String) -> String) -> Closeable {
    return UILabelExtKt.bindText(self, liveData: liveData, formatter: formatter)
  }
}

public extension UIKit.UILabel {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/UIKit/UILabel)/bindText/coroutineScope:Class(name=kotlinx/coroutines/CoroutineScope),flow:Class(name=com/icerockdev/library/CFlow)<Class(name=kotlin/String)>
   */
  @discardableResult
  public func bindText(coroutineScope: CoroutineScope, flow: CFlow<NSString>) {
    return UILabelExtKt.bindText(self, coroutineScope: coroutineScope, flow: flow)
  }
}

public extension Swift.String {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=kotlin/String)/extensionFunctionOnString/
   */
  @discardableResult
  public func extensionFunctionOnString() {
    return ExtensionsKt.extensionFunctionOnString(self)
  }
}

public extension MultiPlatformLibrary.SomeInterface {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=com/icerockdev/library/SomeInterface)/extensionOnInterface/
   */
  @discardableResult
  public func extensionOnInterface() {
    return ExtensionsKt.extensionOnInterface(self)
  }
}

public extension Foundation.NotificationCenter {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/Foundation/NSNotificationCenter.Companion)/extensionOnPlatformCompanion/
   */
  @discardableResult
  public class func extensionOnPlatformCompanion() {
    return PlatformExtensionsKt.extensionOnPlatformCompanion(self)
  }
}

public extension UIKit.UILabel {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/UIKit/UILabel)/fillByKotlin/
   */
  @discardableResult
  public func fillByKotlin() {
    return PlatformExtensionsKt.fillByKotlin(self)
  }
}

public extension UIKit.UILabel {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/UIKit/UILabel)/fillByKotlin/provider:Class(name=com/icerockdev/library/CDataProvider)<Class(name=kotlin/String)>
   */
  @discardableResult
  public func fillByKotlin(provider: CDataProvider<NSString>) {
    return PlatformExtensionsKt.fillByKotlin(self, provider: provider)
  }
}

public extension UIKit.UILabel {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/UIKit/UILabel)/fillByKotlin/provider:Class(name=com/icerockdev/library/IDataProvider)<Class(name=kotlin/String)>
   */
  @discardableResult
  public func fillByKotlin(provider: IDataProvider) {
    return PlatformExtensionsKt.fillByKotlin(self, provider_: provider)
  }
}

public extension UIKit.UILabel {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=platform/UIKit/UILabel)/fillByKotlin/text:Class(name=kotlin/String)
   */
  @discardableResult
  public func fillByKotlin(text: String) {
    return PlatformExtensionsKt.fillByKotlin(self, text: text)
  }
}

public extension UIKit.UIControl {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/TypeParameter(id=0)/setEventHandler/event:Class(name=kotlin/ULong),lambda:Class(name=kotlin/Function1)<TypeParameter(id=0),Class(name=kotlin/Unit)>
   */
  @discardableResult
  public func setEventHandler<T : UIControl>(event: UInt64, lambda: @escaping (T) -> Void) -> Closeable {
    return PlatformExtensionsKt.setEventHandler(self, event: event, lambda: lambda as! (UIKit.UIControl) -> Swift.Void)
  }
}

public extension Swift.String {
  /**
   * selector: PackageFunctionContext/moko-kswift.sample:mpp-library/com.icerockdev.library/Class(name=kotlin/String)/stringToThrowable/
   */
  @discardableResult
  public func stringToThrowable() -> KotlinThrowable {
    return ExtensionsKt.stringToThrowable(self)
  }
}
